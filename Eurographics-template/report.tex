% ---------------------------------------------------------------------------
% Author guideline and sample document for EG publication using LaTeX2e input
% D.Fellner, v2, June 1, 2017

\documentclass{egpubl}

% --- for  Annual CONFERENCE
% \ConferenceSubmission % uncomment for Conference submission
% \ConferencePaper      % uncomment for (final) Conference Paper
% \STAR                 % uncomment for STAR contribution
% \Tutorial             % uncomment for Tutorial contribution
% \ShortPresentation    % uncomment for (final) Short Conference Presentation
%
% --- for  CGF Journal
\JournalSubmission    % uncomment for submission to Computer Graphics Forum
%  \JournalPaper         % uncomment for final version of Journal Paper (NOTE: this won't have page numbers)
%
% --- for  CGF Journal: special issue
% \SpecialIssueSubmission    % uncomment for submission to Computer Graphics Forum, special issue
% \SpecialIssuePaper         % uncomment for final version of Journal Paper, special issue
%
% --- for  EG Workshop Proceedings
% \WsSubmission    % uncomment for submission to EG Workshop
% \WsPaper         % uncomment for final version of EG Workshop contribution
%
 \electronicVersion % can be used both for the printed and electronic version

% !! *please* don't change anything above
% !! unless you REALLY know what you are doing
% ------------------------------------------------------------------------

% for including postscript figures
% mind: package option 'draft' will replace PS figure by a filname within a frame
\ifpdf \usepackage[pdftex]{graphicx} \pdfcompresslevel=9
\else \usepackage[dvips]{graphicx} \fi

\PrintedOrElectronic

% prepare for electronic version of your document
\usepackage{t1enc,dfadobe}

\usepackage{egweblnk}
\usepackage{cite}

% For backwards compatibility to old LaTeX type font selection.
% Uncomment if your document adheres to LaTeX2e recommendations.
% \let\rm=\rmfamily    \let\sf=\sffamily    \let\tt=\ttfamily
% \let\it=\itshape     \let\sl=\slshape     \let\sc=\scshape
% \let\bf=\bfseries

% end of prologue

% \input{EGauthorGuidelines-body.inc}

\title[Polygonal Model Compression]%
      {Polygonal Model Compression with Graph Symmetries}

% for anonymous conference submission please enter your SUBMISSION ID
% instead of the author's name (and leave the affiliation blank) !!
\author[Andrej Jočić]
{\parbox{\textwidth}{\centering% D.\,W. Fellner\thanks{Chairman Eurographics Publications Board}$^{1,2}$
        Andrej Jočić$^{1}$ 
%        S. Spencer$^2$\thanks{Chairman Siggraph Publications Board}
        }
        \\
% For Computer Graphics Forum: Please use the abbreviation of your first name.
{\parbox{\textwidth}{\centering %$^1$TU Darmstadt \& Fraunhofer IGD, Germany\\
         $^1$University of Ljubljana, Faculty of Computer and Information Science, Slovenia
%        $^2$ Another Department to illustrate the use in papers from authors
%             with different affiliations
       }
}
}
% ------------------------------------------------------------------------

% if the Editors-in-Chief have given you the data, you may uncomment
% the following five lines and insert it here
%
% \volume{36}   % the volume in which the issue will be published;
% \issue{1}     % the issue number of the publication
% \pStartPage{1}      % set starting page


%-------------------------------------------------------------------------
\begin{document}

% uncomment for using teaser
% \teaser{
%  \includegraphics[width=\linewidth]{eg_new}
%  \centering
%   \caption{New EG Logo}
% \label{fig:teaser}
%}

\maketitle
%-------------------------------------------------------------------------
\begin{abstract}

TODO the abstract
%-------------------------------------------------------------------------
%  ACM CCS 1998
%  (see http://www.acm.org/about/class/1998)
% \begin{classification} % according to http:http://www.acm.org/about/class/1998
% \CCScat{Computer Graphics}{I.3.3}{Picture/Image Generation}{Line and curve generation}
% \end{classification}
%-------------------------------------------------------------------------
%  ACM CCS 2012
   (see http://www.acm.org/about/class/class/2012)
%The tool at \url{http://dl.acm.org/ccs.cfm} can be used to generate
\begin{CCSXML}
    <ccs2012>
    <concept>
    <concept_id>10010147.10010371.10010396.10010397</concept_id>
    <concept_desc>Computing methodologies~Mesh models</concept_desc>
    <concept_significance>500</concept_significance>
    </concept>
    <concept>
    <concept_id>10010147.10010371.10010387.10010394</concept_id>
    <concept_desc>Computing methodologies~Graphics file formats</concept_desc>
    <concept_significance>300</concept_significance>
    </concept>
    <concept>
    <concept_id>10003752.10003809.10010031.10002975</concept_id>
    <concept_desc>Theory of computation~Data compression</concept_desc>
    <concept_significance>100</concept_significance>
    </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computing methodologies~Mesh models}
\ccsdesc[300]{Computing methodologies~Graphics file formats}
\ccsdesc[100]{Theory of computation~Data compression}


\printccsdesc   
\end{abstract}  
%-------------------------------------------------------------------------
\section{Introduction}

Polygonal models are widely used for representing 3D objects in computer graphics. With increased rendering system capabilities and the desire for greater precision, the size of these models has been increasing. To cut down transmission and static storage costs, specialized compression schemes have been developed.
In previously established \cite{meshCompressionSurvey} terms, we will be focusing on lossless single-rate global compression of static polygonal models. This means that we will be considering fixed (non-evolving) data, which will be decompressed it all at once (without progressive transmission at different levels of detail) and in its entirety (not focusing on specific regions of the model as requested by the user).

The information we usually store is the model's geometry (positions of vertices), connectivity / topology (incidence relations among elements), and optionally also attributes (normals, colours, etc.).
Typically the connectivity information takes up the most space (around twice as much as the goemetry information in a triangle mesh homeomorphic to a sphere \cite{rossignac1999edgebreaker}), so it is the most important to compress.
Many compression methods focus exclusively on manifold triangle meshes (or another constrained structure) to get the best possible results.  
In this paper we will consider the case of arbitrary polygonal models. Since the connectivity relations can be represented as an undirected graph, we can reduce the problem to that of graph compression.
One issue with this approach is that we lose face orientation data, which renderers need for shading and face culling. If a renderer can't infer consistent face orientations from just the wireframe, we will need to encode this information separately. This is briefly discussed in section TODO.

Specifically, we will be exploiting symmetries in the graph, which can often occur in the graphical domain.

\section{Mesh File Formats}

A typical mesh file format (e.g. OFF, PLY) encodes the connectivity information as a list of faces, where each face is a list of vertex indices. Within a face we have one vertex index per edge, but usually the majority of edges are shared between two faces (assuming relatively few boundary edges). This means we have about 2 vertex indices per edge, which is a baseline for storing graphs. To do any better, we must encode the connectivity with less than 2 indices per edge, meaning we need to somehow compress the graph. In this paper, we will use local symmetries in the graph to achieve this.

We decided to support compression and decompression of PLY files, since they are widely adopted and relatively simple in terms of structure.
Note that PLY has two formats: compact binary and human-readable ASCII. When reporting compression rates, we will be considering the binary format for a fair comparison with our (binary) compressed files.

% \subsection{Related Work}

% TODO: slap some survey papers in here (graph compression, mesh compression)

% TODO: list connectivity comp. rates from survey table 1
% this and that paper has dealt with symmetry-based mesh compression, but to our knowledge it has not been done with automorphisms.

\section{Symmetry Compression}

If we are willing to give up the vertex information (and infer positions with a layout algorithm), we can just compress the connectivity information. In this case compressing the face incidence graph is a viable option, since we don't have to list the vertices of each face but just an arbitrary identifier. Then we can get the 1-skeleton of the model by computing the dual of the decompressed face incidence graph.

Čibej and Mihelič \cite{cibej2021automorphisms} have developed a method general graph compression based on automorphisms. They define
\textit{symmetry-compressible} graphs $G$
as ones that can be more succinctly represented with a ``residual'' graph $G^\pi$ and an automorphism (connectivity-preserving vertex permutation) $\pi$ of $G$.
Formally, $G \in \mathcal{S}\mathcal{C}$ if $\exists \pi \in Aut(G)$ such that $|G^\pi| + |\pi| < |G|$, where $|\cdot|$ denotes a measure of representation size (e.g. number of edges). 

A class of graphs more amenable to practical compression are \textit{near symmetry-compressible} graphs. 
% TODO: define near symmetry-compressible graphs


The main computational issue is finding a (compressive) automorphism. The paper presents two approaches: graphlet search and bipartite completion.
As Theorem TODO shows, we can just search for SC subgraphs.

\subsection{Bipartite Completion}

Though in principle we could use a single structure instead of a list, this may result in a non-disjoint set of cycles for the permutation. We could get around this by considering all options at decompression??

Though a star graph is a common occurence in the graphical domain, it is unfortunately not symmetry-compressible (measuring size by number of edges) (??) do we only need NSC?

Note that the only complete bipartite graphs that are planar are $K_{1,n}$ (a star) and $K_{2,n}$, but the former is not symmetry-compressible. (Wagner's theorem)

The 1-skeletons of manifold meshes (which the vast majority of real-world models are) are planar graphs. So the face adjacency graph, which is the dual of the 1-skeleton, is also planar. This means these graphs are very sparse with $m = O(n)$, where $n$ is the number of vertices and $m$ is the number of edges. This easily explains the poor performance of the bipartite completion method, since many edges have to be added to make a complete bipartite subgraph.  


\subsection{Graphlet Search}
% This one is a lot slower, but may be more appropriate for our case (if we're not compressing on the fly during transmission).
Another approach they present is to search for symmetry-compressible subgraphs. Going through all graphlets up to a certain size (in decreasing order of relative compression efficiency). Then a maximal edge-disjoint set of SC subgraphs is greedily selected to be replaced by their CS representations. We have opted to modify this approach with the help of a \textit{graph atlas} \cite{read1998atlas}, a systematic enumrations of all undirected graphs up to a cerain length. Python's networkx library, which we have chosen for most of our graph data processing, provides access to the 1253 graphlets with $n \leq 7$.
Instead of $(\pi, H^\pi)$ we simply store $H$'s atlas index and a mapping between nodes of $G$ and $H$.
It makes sense in this case because we are only looking for small subgraphs.
Any more than that acn result in unreasonable compression times anyway.
This may be seen as a dictionary-based graph encoding. Since this takes only $1 + n$ integers to store, it is always at least as efficient as the CS representation since an encoding of $\pi$ requires at least $n$ integers.

\subsection{Compressed file format}
Most commonly used file formats for storing 3D models have the following structure: a header with metadata, then the vertex data, and finally the connectivity data. Connectivity data is usually stored as a list of faces, where each face is a list of vertex indices. This means the graph we will be compressing is the 1-skeleton of the model. Alternatively we could compress the face adjacency graph, but this would just inflate such an input file.

When decompressing, we will need to compute the facial walks of the skeleton in order to produce the original face list.

\section{Decompresion}

note that enumerating faces can take quite a while. for triangle mesh, complexity is TODO % see nx documentation notes

\section{Results}


\section{Discussion}


\subsection{Future Work}
\begin{itemize}
        \item bit-efficient encoding (instead of pickle dump)
        \item graphlet heuristic sort with eg. orbit counting stats
        \item alternative automorphism search algorithms, suited to the graphical domain
\end{itemize}

\subsection{Conclusions}


%-------------------------------------------------------------------------

%\bibliographystyle{eg-alpha}
\bibliographystyle{eg-alpha-doi}

\bibliography{references}

\end{document}
